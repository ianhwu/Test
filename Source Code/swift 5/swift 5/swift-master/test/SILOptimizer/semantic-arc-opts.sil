// RUN: %target-sil-opt -module-name Swift -enable-sil-verify-all -semantic-arc-opts %s | %FileCheck %s

sil_stage raw

import Builtin

//////////////////
// Declarations //
//////////////////

enum MyNever {}

sil @guaranteed_user : $@convention(thin) (@guaranteed Builtin.NativeObject) -> ()
sil @owned_user : $@convention(thin) (@owned Builtin.NativeObject) -> ()
sil @get_owned_obj : $@convention(thin) () -> @owned Builtin.NativeObject
sil @unreachable_guaranteed_user : $@convention(thin) (@guaranteed Builtin.NativeObject) -> MyNever

struct NativeObjectPair {
  var obj1 : Builtin.NativeObject
  var obj2 : Builtin.NativeObject
}

sil @get_nativeobject_pair : $@convention(thin) () -> @owned NativeObjectPair

class Klass {}

struct MyInt {
  var value: Builtin.Int32
}

struct AnotherStruct {
  var i : Builtin.Int32
  var c : Klass
}

struct StructMemberTest {
  var c : Klass
  var s : AnotherStruct
  var t : (Builtin.Int32, AnotherStruct)
}

enum FakeOptional<T> {
case none
case some(T)
}

class ClassLet {
  @_hasStorage let aLet: Klass
  @_hasStorage var aVar: Klass
  @_hasStorage let aLetTuple: (Klass, Klass)

  @_hasStorage let anotherLet: ClassLet
}

class SubclassLet: ClassLet {}

sil_global [let] @a_let_global : $Klass
sil_global @a_var_global : $Klass

///////////
// Tests //
///////////

// CHECK-LABEL: sil [ossa] @argument_only_destroy_user_test : $@convention(thin) (@guaranteed Builtin.NativeObject) -> () {
// CHECK-NOT: copy_value
// CHECK-NOT: destroy_value
sil [ossa] @argument_only_destroy_user_test : $@convention(thin) (@guaranteed Builtin.NativeObject) -> () {
bb0(%0 : @guaranteed $Builtin.NativeObject):
  %1 = copy_value %0 : $Builtin.NativeObject
  destroy_value %1 : $Builtin.NativeObject
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil [ossa] @argument_diamond_test_case : $@convention(thin) (@guaranteed Builtin.NativeObject) -> @owned Builtin.NativeObject {
// CHECK: bb0([[ARG:%.*]] : @guaranteed $Builtin.NativeObject):
// CHECK-NEXT: [[RESULT:%.*]] = copy_value [[ARG]]
// CHECK-NEXT: cond_br undef, [[LHSBB:bb[0-9]+]], [[RHSBB:bb[0-9]+]]
//
// CHECK: [[LHSBB]]:
// CHECK-NEXT: br [[EPILOGBB:bb[0-9]+]]
//
// CHECK: [[RHSBB]]:
// CHECK-NEXT: br [[EPILOGBB]]
//
// CHECK: [[EPILOGBB]]:
// CHECK-NEXT: return [[RESULT]]
sil [ossa] @argument_diamond_test_case : $@convention(thin) (@guaranteed Builtin.NativeObject) -> @owned Builtin.NativeObject {
bb0(%0 : @guaranteed $Builtin.NativeObject):
  %1 = copy_value %0 : $Builtin.NativeObject
  %2 = copy_value %1 : $Builtin.NativeObject
  cond_br undef, bb1, bb2

bb1:
  destroy_value %1 : $Builtin.NativeObject
  br bb3

bb2:
  destroy_value %1 : $Builtin.NativeObject
  br bb3

bb3:
  return %2 : $Builtin.NativeObject
}

// CHECK-LABEL: sil [ossa] @argument_copy_borrow_test_case : $@convention(thin) (@guaranteed Builtin.NativeObject) -> () {
// CHECK: bb0([[ARG:%.*]] : @guaranteed $Builtin.NativeObject
// CHECK-NOT: copy_value
// CHECK-NOT: begin_borrow
// CHECK: apply {{%.*}}([[ARG]])
// CHECK-NOT: end_borrow
// CHECK-NOT: destroy_value
// CHECK: } // end sil function 'argument_copy_borrow_test_case'
sil [ossa] @argument_copy_borrow_test_case : $@convention(thin) (@guaranteed Builtin.NativeObject) -> () {
bb0(%0 : @guaranteed $Builtin.NativeObject):
  %1 = copy_value %0 : $Builtin.NativeObject
  %2 = function_ref @guaranteed_user : $@convention(thin) (@guaranteed Builtin.NativeObject) -> ()
  %3 = begin_borrow %1 : $Builtin.NativeObject
  apply %2(%3) : $@convention(thin) (@guaranteed Builtin.NativeObject) -> ()
  end_borrow %3 : $Builtin.NativeObject
  destroy_value %1 : $Builtin.NativeObject
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil [ossa] @argument_copy_of_copy : $@convention(thin) (@guaranteed Builtin.NativeObject) -> () {
// CHECK: bb0
// CHECK-NEXT: tuple
// CHECK-NEXT: return
// CHECK-NEXT: } // end sil function 'argument_copy_of_copy'
sil [ossa] @argument_copy_of_copy : $@convention(thin) (@guaranteed Builtin.NativeObject) -> () {
bb0(%0 : @guaranteed $Builtin.NativeObject):
  %1 = copy_value %0 : $Builtin.NativeObject
  %2 = begin_borrow %1 : $Builtin.NativeObject
  %3 = copy_value %2 : $Builtin.NativeObject
  %4 = begin_borrow %3 : $Builtin.NativeObject
  end_borrow %4 : $Builtin.NativeObject
  destroy_value %3 : $Builtin.NativeObject
  end_borrow %2 : $Builtin.NativeObject
  destroy_value %1 : $Builtin.NativeObject
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil [ossa] @copy_struct_extract_guaranteed_use : $@convention(thin) (@guaranteed NativeObjectPair) -> () {
// CHECK: bb0([[ARG:%.*]] : @guaranteed $NativeObjectPair):
// CHECK-NOT: copy_value
// CHECK-NOT: begin_borrow
// CHECK:   [[FIELD:%.*]] = struct_extract [[ARG]]
// CHECK:   apply {{%.*}}([[FIELD]]) :
// CHECK-NEXT: tuple
// CHECK-NEXT: return
// CHECK: } // end sil function 'copy_struct_extract_guaranteed_use'
sil [ossa] @copy_struct_extract_guaranteed_use : $@convention(thin) (@guaranteed NativeObjectPair) -> () {
bb0(%0 : @guaranteed $NativeObjectPair):
  %1 = copy_value %0 : $NativeObjectPair
  %2 = begin_borrow %1 : $NativeObjectPair
  %3 = struct_extract %2 : $NativeObjectPair, #NativeObjectPair.obj1
  %4 = function_ref @guaranteed_user : $@convention(thin) (@guaranteed Builtin.NativeObject) -> ()
  apply %4(%3) : $@convention(thin) (@guaranteed Builtin.NativeObject) -> ()
  end_borrow %2 : $NativeObjectPair
  destroy_value %1 : $NativeObjectPair
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil [ossa] @struct_extract_copy_guaranteed_use : $@convention(thin) (@guaranteed NativeObjectPair) -> () {
// CHECK: bb0([[ARG:%.*]] : @guaranteed $NativeObjectPair):
// CHECK:   [[FIELD:%.*]] = struct_extract [[ARG]]
// CHECK:   apply {{%.*}}([[FIELD]])
// CHECK-NOT: destroy_value
// CHECK: } // end sil function 'struct_extract_copy_guaranteed_use'
sil [ossa] @struct_extract_copy_guaranteed_use : $@convention(thin) (@guaranteed NativeObjectPair) -> () {
bb0(%0 : @guaranteed $NativeObjectPair):
  %1 = struct_extract %0 : $NativeObjectPair, #NativeObjectPair.obj1
  %2 = copy_value %1 : $Builtin.NativeObject
  %3 = begin_borrow %2 : $Builtin.NativeObject
  %4 = function_ref @guaranteed_user : $@convention(thin) (@guaranteed Builtin.NativeObject) -> ()
  apply %4(%3) : $@convention(thin) (@guaranteed Builtin.NativeObject) -> ()
  end_borrow %3 : $Builtin.NativeObject
  destroy_value %2 : $Builtin.NativeObject
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil [ossa] @process_forwarding_uses : $@convention(thin) (@guaranteed NativeObjectPair) -> () {
// CHECK-NOT: copy_value
// CHECK: } // end sil function 'process_forwarding_uses'
sil [ossa] @process_forwarding_uses : $@convention(thin) (@guaranteed NativeObjectPair) -> () {
bb0(%0 : @guaranteed $NativeObjectPair):
  %1 = copy_value %0 : $NativeObjectPair
  (%2, %3) = destructure_struct %1 : $NativeObjectPair
  %4 = function_ref @guaranteed_user : $@convention(thin) (@guaranteed Builtin.NativeObject) -> ()
  apply %4(%2) : $@convention(thin) (@guaranteed Builtin.NativeObject) -> ()
  apply %4(%3) : $@convention(thin) (@guaranteed Builtin.NativeObject) -> ()
  destroy_value %2 : $Builtin.NativeObject
  destroy_value %3 : $Builtin.NativeObject
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil [ossa] @process_forwarding_uses_2 : $@convention(thin) (@guaranteed Builtin.NativeObject) -> () {
// CHECK-NOT: copy_value
// CHECK: } // end sil function 'process_forwarding_uses_2'
sil [ossa] @process_forwarding_uses_2 : $@convention(thin) (@guaranteed Builtin.NativeObject) -> () {
bb0(%0 : @guaranteed $Builtin.NativeObject):
  %1 = copy_value %0 : $Builtin.NativeObject
  %2 = unchecked_ref_cast %1 : $Builtin.NativeObject to $Builtin.NativeObject
  %4 = function_ref @guaranteed_user : $@convention(thin) (@guaranteed Builtin.NativeObject) -> ()
  apply %4(%2) : $@convention(thin) (@guaranteed Builtin.NativeObject) -> ()
  destroy_value %2 : $Builtin.NativeObject
  %9999 = tuple()
  return %9999 : $()
}

// Do not eliminate a copy from an unowned value. This will cause us to pass the
// unowned value as guaranteed... =><=.
//
// CHECK-LABEL: sil [ossa] @unowned_arg_copy : $@convention(thin) (Builtin.NativeObject) -> () {
// CHECK: copy_value
// CHECK: } // end sil function 'unowned_arg_copy'
sil [ossa] @unowned_arg_copy : $@convention(thin) (Builtin.NativeObject) -> () {
bb0(%0 : @unowned $Builtin.NativeObject):
  %1 = copy_value %0 : $Builtin.NativeObject
  %2 = function_ref @guaranteed_user : $@convention(thin) (@guaranteed Builtin.NativeObject) -> ()
  apply %2(%1) : $@convention(thin) (@guaranteed Builtin.NativeObject) -> ()
  destroy_value %1 : $Builtin.NativeObject
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil [ossa] @dead_live_range_multiple_destroy_value : $@convention(thin) (@owned Builtin.NativeObject) -> () {
// CHECK-NOT: copy_value
// CHECK-NOT: destroy_value
// CHECK: bb3:
// CHECK:     destroy_value
// CHECK: } // end sil function 'dead_live_range_multiple_destroy_value'
sil [ossa] @dead_live_range_multiple_destroy_value : $@convention(thin) (@owned Builtin.NativeObject) -> () {
bb0(%0 : @owned $Builtin.NativeObject) :
  %1 = copy_value %0 : $Builtin.NativeObject
  cond_br undef, bb1, bb2

bb1:
  destroy_value %1 : $Builtin.NativeObject
  br bb3

bb2:
  destroy_value %1 : $Builtin.NativeObject
  br bb3

bb3:
  destroy_value %0 : $Builtin.NativeObject
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil [ossa] @dead_live_range_multiple_destroy_value_consuming_user : $@convention(thin) (@owned Builtin.NativeObject) -> () {
// CHECK: copy_value
// CHECK: destroy_value
// CHECK: destroy_value
// CHECK: } // end sil function 'dead_live_range_multiple_destroy_value_consuming_user'
sil [ossa] @dead_live_range_multiple_destroy_value_consuming_user : $@convention(thin) (@owned Builtin.NativeObject) -> () {
bb0(%0 : @owned $Builtin.NativeObject) :
  %1 = copy_value %0 : $Builtin.NativeObject
  cond_br undef, bb1, bb2

bb1:
  destroy_value %1 : $Builtin.NativeObject
  br bb3

bb2:
  %2 = function_ref @owned_user : $@convention(thin) (@owned Builtin.NativeObject) -> ()
  apply %2(%1) : $@convention(thin) (@owned Builtin.NativeObject) -> ()
  br bb3

bb3:
  destroy_value %0 : $Builtin.NativeObject
  %9999 = tuple()
  return %9999 : $()
}

// Simple in_guaranteed argument load_copy.
// CHECK-LABEL: sil [ossa] @load_copy_from_in_guaranteed : $@convention(thin) (@in_guaranteed Builtin.NativeObject) -> () {
// CHECK: bb0([[ARG:%.*]] :
// CHECK: load_borrow
// CHECK: load_borrow
// CHECK: load [copy]
// CHECK: } // end sil function 'load_copy_from_in_guaranteed'
sil [ossa] @load_copy_from_in_guaranteed : $@convention(thin) (@in_guaranteed Builtin.NativeObject) -> () {
bb0(%0 : $*Builtin.NativeObject):
  %g = function_ref @guaranteed_user : $@convention(thin) (@guaranteed Builtin.NativeObject) -> ()
  // Simple same bb.
  %1 = load [copy] %0 : $*Builtin.NativeObject
  apply %g(%1) : $@convention(thin) (@guaranteed Builtin.NativeObject) -> ()
  destroy_value %1 : $Builtin.NativeObject

  // Diamond.
  %2 = load [copy] %0 : $*Builtin.NativeObject
  cond_br undef, bb1, bb2

bb1:
  apply %g(%2) : $@convention(thin) (@guaranteed Builtin.NativeObject) -> ()
  destroy_value %2 : $Builtin.NativeObject
  br bb3

bb2:
  destroy_value %2 : $Builtin.NativeObject
  br bb3

bb3:
  // Consuming use blocks.
  %3 = load [copy] %0 : $*Builtin.NativeObject
  %4 = function_ref @owned_user : $@convention(thin) (@owned Builtin.NativeObject) -> ()
  apply %4(%3) : $@convention(thin) (@owned Builtin.NativeObject) -> ()
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil [ossa] @destructure_test : $@convention(thin) (@guaranteed StructMemberTest) -> Builtin.Int32 {
// CHECK: bb0([[ARG:%.*]] : @guaranteed $StructMemberTest):
// CHECK:   [[EXT:%.*]] = struct_extract [[ARG]]
// CHECK:   ([[DEST_1:%.*]], [[DEST_2:%.*]]) = destructure_tuple [[EXT]]
// CHECK:   [[RESULT:%.*]] = struct_extract [[DEST_2]]
// CHECK:   return [[RESULT]]
// CHECK: } // end sil function 'destructure_test'
sil [ossa] @destructure_test : $@convention(thin) (@guaranteed StructMemberTest) -> Builtin.Int32 {
bb0(%0 : @guaranteed $StructMemberTest):
  %2 = struct_extract %0 : $StructMemberTest, #StructMemberTest.t
  %3 = copy_value %2 : $(Builtin.Int32, AnotherStruct)
  (%4, %5) = destructure_tuple %3 : $(Builtin.Int32, AnotherStruct)
  %6 = begin_borrow %5 : $AnotherStruct
  %7 = struct_extract %6 : $AnotherStruct, #AnotherStruct.i
  end_borrow %6 : $AnotherStruct
  destroy_value %5 : $AnotherStruct
  return %7 : $Builtin.Int32
}

// Make sure that in a case where we have multiple non-trivial values passed to
// a forwarding instruction we do not optimize... but if we only have one (and
// multiple trivial arguments), we can.
//
// CHECK-LABEL: sil [ossa] @multiple_arg_forwarding_inst_test : $@convention(thin) (@guaranteed Builtin.NativeObject, @guaranteed Builtin.NativeObject, Builtin.Int32) -> () {
// CHECK: copy_value
// CHECK: copy_value
// CHECK-NOT: copy_value
// CHECK: } // end sil function 'multiple_arg_forwarding_inst_test'
sil [ossa] @multiple_arg_forwarding_inst_test : $@convention(thin) (@guaranteed Builtin.NativeObject, @guaranteed Builtin.NativeObject, Builtin.Int32) -> () {
bb0(%0 : @guaranteed $Builtin.NativeObject, %1 : @guaranteed $Builtin.NativeObject, %1a : $Builtin.Int32):
  %2 = copy_value %0 : $Builtin.NativeObject
  %3 = copy_value %1 : $Builtin.NativeObject
  %4 = tuple(%2 : $Builtin.NativeObject, %3 : $Builtin.NativeObject)
  destroy_value %4 : $(Builtin.NativeObject, Builtin.NativeObject)

  %5 = copy_value %0 : $Builtin.NativeObject
  %6 = tuple(%5 : $Builtin.NativeObject, %1a : $Builtin.Int32)
  destroy_value %6 : $(Builtin.NativeObject, Builtin.Int32)

  %9999 = tuple()
  return %9999 : $()
}

// TODO: We should be able to optimize these switch_enum. Make sure that today
// we do not do so though.
// CHECK-LABEL: sil [ossa] @switch_enum_test_no_default : $@convention(thin) (@guaranteed FakeOptional<Builtin.NativeObject>) -> () {
// CHECK: copy_value
// CHECK: } // end sil function 'switch_enum_test_no_default'
sil [ossa] @switch_enum_test_no_default : $@convention(thin) (@guaranteed FakeOptional<Builtin.NativeObject>) -> () {
bb0(%0 : @guaranteed $FakeOptional<Builtin.NativeObject>):
  %1 = copy_value %0 : $FakeOptional<Builtin.NativeObject>
  switch_enum %1 : $FakeOptional<Builtin.NativeObject>, case #FakeOptional.some!enumelt.1: bb1, case #FakeOptional.none!enumelt: bb2

bb1(%2 : @owned $Builtin.NativeObject):
  destroy_value %2 : $Builtin.NativeObject
  br bb3

bb2:
  br bb3

bb3:
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil [ossa] @switch_enum_test_with_default : $@convention(thin) (@guaranteed FakeOptional<Builtin.NativeObject>) -> () {
// CHECK: copy_value
// CHECK: } // end sil function 'switch_enum_test_with_default'
sil [ossa] @switch_enum_test_with_default : $@convention(thin) (@guaranteed FakeOptional<Builtin.NativeObject>) -> () {
bb0(%0 : @guaranteed $FakeOptional<Builtin.NativeObject>):
  %1 = copy_value %0 : $FakeOptional<Builtin.NativeObject>
  switch_enum %1 : $FakeOptional<Builtin.NativeObject>, case #FakeOptional.some!enumelt.1: bb1, default bb2

bb1(%2 : @owned $Builtin.NativeObject):
  destroy_value %2 : $Builtin.NativeObject
  br bb3

bb2(%3 : @owned $FakeOptional<Builtin.NativeObject>):
  destroy_value %3 : $FakeOptional<Builtin.NativeObject>
  br bb3

bb3:
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil [ossa] @do_not_add_trivial_users_of_owned_values_to_isconsumed_worklist : $@convention(thin) (@guaranteed (Klass, MyInt)) -> Builtin.Int32 {
// CHECK-NOT: copy_value
// CHECK-NOT: destroy_value
// CHECK: } // end sil function 'do_not_add_trivial_users_of_owned_values_to_isconsumed_worklist'
sil [ossa] @do_not_add_trivial_users_of_owned_values_to_isconsumed_worklist : $@convention(thin) (@guaranteed (Klass, MyInt)) -> Builtin.Int32 {
bb0(%0 : @guaranteed $(Klass, MyInt)):
  %1 = copy_value %0 : $(Klass, MyInt)
  (%2, %3) = destructure_tuple %1 : $(Klass, MyInt)
  %4 = struct_extract %3 : $MyInt, #MyInt.value
  destroy_value %2 : $Klass
  return %4 : $Builtin.Int32
}

sil [ossa] @black_hole : $@convention(thin) (@guaranteed Klass) -> ()

// CHECK-LABEL: sil [ossa] @dont_copy_let_properties_with_guaranteed_base
// CHECK:         ref_element_addr
// CHECK-NEXT:    load_borrow
// CHECK-NEXT:    apply
// CHECK-NEXT:    end_borrow
// CHECK-NEXT:    return
sil [ossa] @dont_copy_let_properties_with_guaranteed_base : $@convention(thin) (@guaranteed ClassLet) -> () {
bb0(%x : @guaranteed $ClassLet):
  %f = function_ref @black_hole : $@convention(thin) (@guaranteed Klass) -> ()

  %p = ref_element_addr %x : $ClassLet, #ClassLet.aLet
  %v = load [copy] %p : $*Klass
  %b = begin_borrow %v : $Klass
  apply %f(%b) : $@convention(thin) (@guaranteed Klass) -> ()
  end_borrow %b : $Klass
  destroy_value %v : $Klass

  return undef : $()
}

// CHECK-LABEL: sil [ossa] @dont_copy_let_properties_with_guaranteed_upcast_base
// CHECK:         ref_element_addr
// CHECK-NEXT:    load_borrow
// CHECK-NEXT:    apply
// CHECK-NEXT:    end_borrow
// CHECK-NEXT:    return
sil [ossa] @dont_copy_let_properties_with_guaranteed_upcast_base : $@convention(thin) (@guaranteed SubclassLet) -> () {
bb0(%x : @guaranteed $SubclassLet):
  %f = function_ref @black_hole : $@convention(thin) (@guaranteed Klass) -> ()

  %u = upcast %x : $SubclassLet to $ClassLet
  %p = ref_element_addr %u : $ClassLet, #ClassLet.aLet
  %v = load [copy] %p : $*Klass
  %b = begin_borrow %v : $Klass
  apply %f(%b) : $@convention(thin) (@guaranteed Klass) -> ()
  end_borrow %b : $Klass
  destroy_value %v : $Klass

  return undef : $()
}

// CHECK-LABEL: sil [ossa] @dont_copy_let_global
// CHECK:         global_addr
// CHECK-NEXT:    load_borrow
// CHECK-NEXT:    apply
// CHECK-NEXT:    end_borrow
// CHECK-NEXT:    return
sil [ossa] @dont_copy_let_global : $@convention(thin) () -> () {
bb0:
  %f = function_ref @black_hole : $@convention(thin) (@guaranteed Klass) -> ()

  %p = global_addr @a_let_global : $*Klass
  %v = load [copy] %p : $*Klass
  %b = begin_borrow %v : $Klass
  apply %f(%b) : $@convention(thin) (@guaranteed Klass) -> ()
  end_borrow %b : $Klass
  destroy_value %v : $Klass

  return undef : $()
}

// CHECK-LABEL: sil [ossa] @dont_copy_let_properties_with_guaranteed_base_structural
// CHECK:         ref_element_addr
// CHECK-NEXT:    tuple_element_addr
// CHECK-NEXT:    load_borrow
// CHECK-NEXT:    apply
// CHECK-NEXT:    end_borrow
// CHECK-NEXT:    return
sil [ossa] @dont_copy_let_properties_with_guaranteed_base_structural : $@convention(thin) (@guaranteed ClassLet) -> () {
bb0(%x : @guaranteed $ClassLet):
  %f = function_ref @black_hole : $@convention(thin) (@guaranteed Klass) -> ()

  %p = ref_element_addr %x : $ClassLet, #ClassLet.aLetTuple
  %q = tuple_element_addr %p : $*(Klass, Klass), 1
  %v = load [copy] %q : $*Klass
  %b = begin_borrow %v : $Klass
  apply %f(%b) : $@convention(thin) (@guaranteed Klass) -> ()
  end_borrow %b : $Klass
  destroy_value %v : $Klass

  return undef : $()
}

// CHECK-LABEL: sil [ossa] @do_copy_var_properties_with_guaranteed_base
// CHECK:         ref_element_addr
// CHECK-NEXT:    load [copy]
// CHECK-NEXT:    apply
// CHECK-NEXT:    destroy
// CHECK-NEXT:    return
sil [ossa] @do_copy_var_properties_with_guaranteed_base : $@convention(thin) (@guaranteed ClassLet) -> () {
bb0(%x : @guaranteed $ClassLet):
  %f = function_ref @black_hole : $@convention(thin) (@guaranteed Klass) -> ()

  %p = ref_element_addr %x : $ClassLet, #ClassLet.aVar
  %v = load [copy] %p : $*Klass
  %b = begin_borrow %v : $Klass
  apply %f(%b) : $@convention(thin) (@guaranteed Klass) -> ()
  end_borrow %b : $Klass
  destroy_value %v : $Klass

  return undef : $()
}

// CHECK-LABEL: sil [ossa] @do_copy_var_global
// CHECK:         global_addr
// CHECK-NEXT:    load [copy]
// CHECK-NEXT:    apply
// CHECK-NEXT:    destroy
// CHECK-NEXT:    return
sil [ossa] @do_copy_var_global : $@convention(thin) () -> () {
bb0:
  %f = function_ref @black_hole : $@convention(thin) (@guaranteed Klass) -> ()

  %p = global_addr @a_var_global : $*Klass
  %v = load [copy] %p : $*Klass
  %b = begin_borrow %v : $Klass
  apply %f(%b) : $@convention(thin) (@guaranteed Klass) -> ()
  end_borrow %b : $Klass
  destroy_value %v : $Klass

  return undef : $()
}

// CHECK-LABEL: sil [ossa] @dont_copy_let_properties_with_borrowed_base_that_dominates
// CHECK:         [[OUTER:%.*]] = begin_borrow
// CHECK-NEXT:    ref_element_addr
// CHECK-NEXT:    [[INNER:%.*]] = load_borrow
// CHECK-NEXT:    apply
// CHECK-NEXT:    end_borrow [[INNER]]
// CHECK-NEXT:    end_borrow [[OUTER]]
// CHECK-NEXT:    destroy_value
sil [ossa] @dont_copy_let_properties_with_borrowed_base_that_dominates : $@convention(thin) (@owned ClassLet) -> () {
bb0(%x : @owned $ClassLet):
  %f = function_ref @black_hole : $@convention(thin) (@guaranteed Klass) -> ()

  %a = begin_borrow %x : $ClassLet
  %p = ref_element_addr %a : $ClassLet, #ClassLet.aLet
  %v = load [copy] %p : $*Klass
  %b = begin_borrow %v : $Klass
  apply %f(%b) : $@convention(thin) (@guaranteed Klass) -> ()
  end_borrow %b : $Klass
  destroy_value %v : $Klass

  end_borrow %a : $ClassLet
  destroy_value %x : $ClassLet

  return undef : $()
}

// CHECK-LABEL: sil [ossa] @dont_copy_let_properties_with_multi_borrowed_base_that_dominates
// CHECK:         [[OUTER:%.*]] = begin_borrow
// CHECK-NEXT:    ref_element_addr
// CHECK-NEXT:    [[INNER:%.*]] = load_borrow
// CHECK-NEXT:    apply
// CHECK-NEXT:    end_borrow [[INNER]]
// CHECK-NEXT:    end_borrow [[OUTER]]
// CHECK-NEXT:    [[OUTER:%.*]] = begin_borrow
// CHECK-NEXT:    ref_element_addr
// CHECK-NEXT:    [[INNER:%.*]] = load_borrow
// CHECK-NEXT:    apply
// CHECK-NEXT:    end_borrow [[INNER]]
// CHECK-NEXT:    end_borrow [[OUTER]]
// CHECK-NEXT:    destroy_value
sil [ossa] @dont_copy_let_properties_with_multi_borrowed_base_that_dominates : $@convention(thin) (@owned ClassLet) -> () {
bb0(%x : @owned $ClassLet):
  %f = function_ref @black_hole : $@convention(thin) (@guaranteed Klass) -> ()

  %a = begin_borrow %x : $ClassLet
  %p = ref_element_addr %a : $ClassLet, #ClassLet.aLet
  %v = load [copy] %p : $*Klass
  %c = begin_borrow %v : $Klass
  apply %f(%c) : $@convention(thin) (@guaranteed Klass) -> ()
  end_borrow %c : $Klass
  destroy_value %v : $Klass
  end_borrow %a : $ClassLet

  %b = begin_borrow %x : $ClassLet
  %q = ref_element_addr %b : $ClassLet, #ClassLet.aLet
  %w = load [copy] %q : $*Klass
  %d = begin_borrow %w : $Klass
  apply %f(%d) : $@convention(thin) (@guaranteed Klass) -> ()
  end_borrow %d : $Klass
  destroy_value %w : $Klass
  end_borrow %b : $ClassLet

  destroy_value %x : $ClassLet

  return undef : $()
}

// CHECK-LABEL: sil [ossa] @do_copy_let_properties_with_borrowed_base_that_does_not_dominate
// CHECK:         begin_borrow
// CHECK-NEXT:    ref_element_addr
// CHECK-NEXT:    load [copy]
// CHECK-NEXT:    apply
// CHECK-NEXT:    end_borrow
// CHECK-NEXT:    destroy_value
// CHECK-NEXT:    apply
// CHECK-NEXT:    destroy_value
sil [ossa] @do_copy_let_properties_with_borrowed_base_that_does_not_dominate : $@convention(thin) (@owned ClassLet) -> () {
bb0(%x : @owned $ClassLet):
  %f = function_ref @black_hole : $@convention(thin) (@guaranteed Klass) -> ()

  %a = begin_borrow %x : $ClassLet
  %p = ref_element_addr %a : $ClassLet, #ClassLet.aLet
  %v = load [copy] %p : $*Klass
  %b = begin_borrow %v : $Klass
  apply %f(%b) : $@convention(thin) (@guaranteed Klass) -> ()

  // End the lifetime of the base object first...
  end_borrow %a : $ClassLet
  destroy_value %x : $ClassLet

  // ...then end the lifetime of the copy.
  apply %f(%b) : $@convention(thin) (@guaranteed Klass) -> ()

  end_borrow %b : $Klass
  destroy_value %v : $Klass

  return undef : $()
}

// CHECK-LABEL: sil [ossa] @do_or_dont_copy_let_properties_with_multi_borrowed_base_when_it_dominates
// CHECK:         [[OUTER:%.*]] = begin_borrow
// CHECK-NEXT:    ref_element_addr
// CHECK-NEXT:    [[INNER:%.*]] = load_borrow
// CHECK-NEXT:    apply
// CHECK-NEXT:    end_borrow [[INNER]]
// CHECK-NEXT:    end_borrow [[OUTER]]
// CHECK-NEXT:    begin_borrow
// CHECK-NEXT:    ref_element_addr
// CHECK-NEXT:    load [copy]
// CHECK-NEXT:    apply
// CHECK-NEXT:    end_borrow
// CHECK-NEXT:    destroy_value
// CHECK-NEXT:    apply
// CHECK-NEXT:    destroy_value
sil [ossa] @do_or_dont_copy_let_properties_with_multi_borrowed_base_when_it_dominates : $@convention(thin) (@owned ClassLet) -> () {
bb0(%x : @owned $ClassLet):
  %f = function_ref @black_hole : $@convention(thin) (@guaranteed Klass) -> ()

  %a = begin_borrow %x : $ClassLet
  %p = ref_element_addr %a : $ClassLet, #ClassLet.aLet
  %v = load [copy] %p : $*Klass
  %c = begin_borrow %v : $Klass
  apply %f(%c) : $@convention(thin) (@guaranteed Klass) -> ()
  end_borrow %c : $Klass
  destroy_value %v : $Klass
  end_borrow %a : $ClassLet

  %b = begin_borrow %x : $ClassLet
  %q = ref_element_addr %b : $ClassLet, #ClassLet.aLet
  %w = load [copy] %q : $*Klass
  %d = begin_borrow %w : $Klass
  apply %f(%d) : $@convention(thin) (@guaranteed Klass) -> ()

  // End the lifetime of the base object first...
  end_borrow %b : $ClassLet
  destroy_value %x : $ClassLet

  // ...then end the lifetime of the copy.
  apply %f(%d) : $@convention(thin) (@guaranteed Klass) -> ()

  end_borrow %d : $Klass
  destroy_value %w : $Klass

  return undef : $()
}

// Make sure that we properly eliminate all ref count ops except for the destroy
// for the @owned argument. The recursion happens since we can not eliminate the
// begin_borrow without eliminating the struct_extract (which we do after we
// eliminate the destroy_value).
// CHECK-LABEL: sil [ossa] @worklist_test : $@convention(thin) (@owned NativeObjectPair) -> () {
// CHECK-NOT: struct_extract
// CHECK: } // end sil function 'worklist_test'
sil [ossa] @worklist_test : $@convention(thin) (@owned NativeObjectPair) -> () {
bb0(%0 : @owned $NativeObjectPair):
  %1 = begin_borrow %0 : $NativeObjectPair
  %2 = struct_extract %1 : $NativeObjectPair, #NativeObjectPair.obj1
  %3 = copy_value %2 : $Builtin.NativeObject
  br bb1

bb1:
  destroy_value %3 : $Builtin.NativeObject
  end_borrow %1 : $NativeObjectPair
  destroy_value %0 : $NativeObjectPair
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil [ossa] @begin_borrow_simple : $@convention(thin) () -> () {
// CHECK-NOT: copy_value
// CHECK: } // end sil function 'begin_borrow_simple'
sil [ossa] @begin_borrow_simple : $@convention(thin) () -> () {
bb0:
  %0 = function_ref @get_nativeobject_pair : $@convention(thin) () -> @owned NativeObjectPair
  %1 = apply %0() : $@convention(thin) () -> @owned NativeObjectPair
  %2 = begin_borrow %1 : $NativeObjectPair
  %3 = struct_extract %2 : $NativeObjectPair, #NativeObjectPair.obj1
  %4 = copy_value %3 : $Builtin.NativeObject
  %5 = function_ref @guaranteed_user : $@convention(thin) (@guaranteed Builtin.NativeObject) -> ()
  apply %5(%4) : $@convention(thin) (@guaranteed Builtin.NativeObject) -> ()
  destroy_value %4 : $Builtin.NativeObject
  end_borrow %2 : $NativeObjectPair
  destroy_value %1 : $NativeObjectPair
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil [ossa] @begin_borrow_fail : $@convention(thin) () -> () {
// CHECK: copy_value
// CHECK: } // end sil function 'begin_borrow_fail'
sil [ossa] @begin_borrow_fail : $@convention(thin) () -> () {
bb0:
  %0 = function_ref @get_nativeobject_pair : $@convention(thin) () -> @owned NativeObjectPair
  %1 = apply %0() : $@convention(thin) () -> @owned NativeObjectPair
  %2 = begin_borrow %1 : $NativeObjectPair
  %3 = struct_extract %2 : $NativeObjectPair, #NativeObjectPair.obj1
  %4 = copy_value %3 : $Builtin.NativeObject
  %5 = function_ref @guaranteed_user : $@convention(thin) (@guaranteed Builtin.NativeObject) -> ()
  apply %5(%4) : $@convention(thin) (@guaranteed Builtin.NativeObject) -> ()
  end_borrow %2 : $NativeObjectPair
  destroy_value %4 : $Builtin.NativeObject
  destroy_value %1 : $NativeObjectPair
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil [ossa] @load_borrow_simple : $@convention(thin) (@in NativeObjectPair) -> () {
// CHECK-NOT: copy_value
// CHECK: } // end sil function 'load_borrow_simple'
sil [ossa] @load_borrow_simple : $@convention(thin) (@in NativeObjectPair) -> () {
bb0(%0 : $*NativeObjectPair):
  %2 = load_borrow %0 : $*NativeObjectPair
  %3 = struct_extract %2 : $NativeObjectPair, #NativeObjectPair.obj1
  %4 = copy_value %3 : $Builtin.NativeObject
  %5 = function_ref @guaranteed_user : $@convention(thin) (@guaranteed Builtin.NativeObject) -> ()
  apply %5(%4) : $@convention(thin) (@guaranteed Builtin.NativeObject) -> ()
  destroy_value %4 : $Builtin.NativeObject
  end_borrow %2 : $NativeObjectPair
  destroy_addr %0 : $*NativeObjectPair
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil [ossa] @load_borrow_fail : $@convention(thin) (@in NativeObjectPair) -> () {
// CHECK: copy_value
// CHECK: } // end sil function 'load_borrow_fail'
sil [ossa] @load_borrow_fail : $@convention(thin) (@in NativeObjectPair) -> () {
bb0(%0 : $*NativeObjectPair):
  %2 = load_borrow %0 : $*NativeObjectPair
  %3 = struct_extract %2 : $NativeObjectPair, #NativeObjectPair.obj1
  %4 = copy_value %3 : $Builtin.NativeObject
  %5 = function_ref @guaranteed_user : $@convention(thin) (@guaranteed Builtin.NativeObject) -> ()
  apply %5(%4) : $@convention(thin) (@guaranteed Builtin.NativeObject) -> ()
  end_borrow %2 : $NativeObjectPair
  destroy_value %4 : $Builtin.NativeObject
  destroy_addr %0 : $*NativeObjectPair
  %9999 = tuple()
  return %9999 : $()
}

// Make sure we do not eliminate the copy_value below to ensure that all uses of
// %2 are before %2's end_borrow.
//
// We used to eliminate the copy_value and change %func to use %2.
//
// CHECK-LABEL: sil [ossa] @begin_borrow_used_by_postdominating_no_return_function : $@convention(thin) () -> MyNever {
// CHECK: copy_value
// CHECK: } // end sil function 'begin_borrow_used_by_postdominating_no_return_function'
sil [ossa] @begin_borrow_used_by_postdominating_no_return_function : $@convention(thin) () -> MyNever {
bb0:
  %0 = function_ref @get_nativeobject_pair : $@convention(thin) () -> @owned NativeObjectPair
  %1 = apply %0() : $@convention(thin) () -> @owned NativeObjectPair
  %2 = begin_borrow %1 : $NativeObjectPair
  %3 = struct_extract %2 : $NativeObjectPair, #NativeObjectPair.obj1
  %4 = copy_value %3 : $Builtin.NativeObject
  end_borrow %2 : $NativeObjectPair
  %func = function_ref @unreachable_guaranteed_user : $@convention(thin) (@guaranteed Builtin.NativeObject) -> MyNever
  apply %func(%4) : $@convention(thin) (@guaranteed Builtin.NativeObject) -> MyNever
  unreachable
}

// Make sure we do not eliminate the copy_value below to ensure that all uses of
// %2 are before %2's end_borrow.
//
// We used to eliminate the copy_value and change %func to use %2.
//
// CHECK-LABEL: sil [ossa] @load_borrow_used_by_postdominating_no_return_function : $@convention(thin) () -> MyNever {
// CHECK: copy_value
// CHECK: } // end sil function 'load_borrow_used_by_postdominating_no_return_function'
sil [ossa] @load_borrow_used_by_postdominating_no_return_function : $@convention(thin) () -> MyNever {
bb0:
  %0 = function_ref @get_nativeobject_pair : $@convention(thin) () -> @owned NativeObjectPair
  %1 = apply %0() : $@convention(thin) () -> @owned NativeObjectPair
  %stackSlot = alloc_stack $NativeObjectPair
  store %1 to [init] %stackSlot : $*NativeObjectPair
  %2 = load_borrow %stackSlot : $*NativeObjectPair
  %3 = struct_extract %2 : $NativeObjectPair, #NativeObjectPair.obj1
  %4 = copy_value %3 : $Builtin.NativeObject
  end_borrow %2 : $NativeObjectPair
  %func = function_ref @unreachable_guaranteed_user : $@convention(thin) (@guaranteed Builtin.NativeObject) -> MyNever
  apply %func(%4) : $@convention(thin) (@guaranteed Builtin.NativeObject) -> MyNever
  unreachable
}

// Make sure that since we have a guaranteed argument and do not need to reason
// about end_borrows, we handle this.
//
// CHECK-LABEL: sil [ossa] @guaranteed_arg_used_by_postdominating_no_return_function : $@convention(thin) (@guaranteed NativeObjectPair) -> MyNever {
// CHECK-NOT: copy_value
// CHECK: } // end sil function 'guaranteed_arg_used_by_postdominating_no_return_function'
sil [ossa] @guaranteed_arg_used_by_postdominating_no_return_function : $@convention(thin) (@guaranteed NativeObjectPair) -> MyNever {
bb0(%0 : @guaranteed $NativeObjectPair):
  %3 = struct_extract %0 : $NativeObjectPair, #NativeObjectPair.obj1
  %4 = copy_value %3 : $Builtin.NativeObject
  %func = function_ref @unreachable_guaranteed_user : $@convention(thin) (@guaranteed Builtin.NativeObject) -> MyNever
  apply %func(%4) : $@convention(thin) (@guaranteed Builtin.NativeObject) -> MyNever
  unreachable
}


// Make sure that since our borrow introducer is a begin_borrow, we do not
// eliminate the copy.
//
// CHECK-LABEL: sil [ossa] @borrowed_val_used_by_postdominating_no_return_function : $@convention(thin) (@owned NativeObjectPair) -> MyNever {
// CHECK: copy_value
// CHECK: } // end sil function 'borrowed_val_used_by_postdominating_no_return_function'
sil [ossa] @borrowed_val_used_by_postdominating_no_return_function : $@convention(thin) (@owned NativeObjectPair) -> MyNever {
bb0(%0 : @owned $NativeObjectPair):
  %1 = begin_borrow %0 : $NativeObjectPair
  %2 = struct_extract %1 : $NativeObjectPair, #NativeObjectPair.obj1
  %3 = copy_value %2 : $Builtin.NativeObject
  %func = function_ref @unreachable_guaranteed_user : $@convention(thin) (@guaranteed Builtin.NativeObject) -> MyNever
  apply %func(%3) : $@convention(thin) (@guaranteed Builtin.NativeObject) -> MyNever
  unreachable
}

// Just make sure that we do not crash on this. We should be able to eliminate
// everything here.
//
// CHECK-LABEL: sil [ossa] @copy_value_with_debug_user : $@convention(thin) (@guaranteed NativeObjectPair) -> () {
// CHECK: bb0
// CHECK-NEXT:  tuple
// CHECK-NEXT:  return
// CHECK-NEXT: } // end sil function 'copy_value_with_debug_user'
sil [ossa] @copy_value_with_debug_user : $@convention(thin) (@guaranteed NativeObjectPair) -> () {
bb0(%0 : @guaranteed $NativeObjectPair):
  %1 = struct_extract %0 : $NativeObjectPair, #NativeObjectPair.obj1
  %2 = copy_value %1 : $Builtin.NativeObject
  debug_value %2 : $Builtin.NativeObject, let, name "myField"
  destroy_value %2 : $Builtin.NativeObject
  %9999 = tuple()
  return %9999 : $()
}

// Just make sure we do not crash here.
//
// CHECK-LABEL: sil [ossa] @do_not_insert_end_borrow_given_deadend : $@convention(thin) (@guaranteed ClassLet) -> () {
// CHECK: copy_value
// CHECK: } // end sil function 'do_not_insert_end_borrow_given_deadend'
sil [ossa] @do_not_insert_end_borrow_given_deadend : $@convention(thin) (@guaranteed ClassLet) -> () {
bb0(%x : @guaranteed $ClassLet):
  %f = function_ref @black_hole : $@convention(thin) (@guaranteed Klass) -> ()
  %p = ref_element_addr %x : $ClassLet, #ClassLet.aLet
  %v = load_borrow %p : $*Klass
  %c = copy_value %v : $Klass
  end_borrow %v : $Klass
  apply %f(%c) : $@convention(thin) (@guaranteed Klass) -> ()
  cond_br undef, bb1, bb2

bb1:
  destroy_value %c : $Klass
  br bb3

bb2:
  destroy_value %c : $Klass
  br bb3

bb3:
  unreachable
}
